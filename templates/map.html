{% extends "base.html" %}
{% block title %}Live Map{% endblock %}

{% block content %}

<style>
  .top-panel {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    background-color: #333;
    color: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    flex-wrap: wrap;
  }

  .top-panel button, .top-panel select {
    background-color: #4CAF50;
    color: white;
    padding: 10px 15px;
    margin: 5px 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s ease;
  }

  .top-panel button:hover, .top-panel select:hover {
    background-color: #45a049;
  }

  #toggleAuto { background-color: #4CAF50; }
  #toggleAuto:hover { background-color: #45a049; }
  #manualRefresh { background-color: #2196F3; }
  #manualRefresh:hover { background-color: #1976D2; }
  #loggingToggle { background-color: #4CAF50; }
  #loggingToggle:hover { background-color: #e53935; }
  #loggingToggle.off { background-color: #f44336; }
  #loggingToggle.off:hover { background-color: #45a049; }

  #map {
    height: 80vh;
    width: 100%;
  }

  #analysis-widget {
    position: absolute;
    top: 20px;           /* adjust to appear below the GPS panel */
    right: 220px;          /* distance from right edge */
    background-color: #333;
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    width: 300px;
    padding: 10px;
    z-index: 998;
    display: none;        /* initially hidden */
  }

  #analysis-widget h4 {
    text-align: center;
    margin-bottom: 10px;
    font-size: 20px;
    color: #ffcc00;
  }

  #analysis-widget button {
    background-color: #2196F3;
  }

  #analysis-widget button:hover {
    background-color: #1976D2;
  }

  #gps-panel {
    position: relative;
    top: 10px;         /* distance from top of page, adjust as needed */
    left: 50px;        /* distance from left edge */
    width: 200px;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px 14px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-family: monospace;
    font-size: 14px;
    color: #000;
    z-index: 999;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }

  #gps-probe {
    font-size: 18px;
    transition: color 0.3s;
  }

  .gps-on {
    color: limegreen;
    animation: blink 0.6s step-start infinite;
  }

  .gps-off {
    color: gray;
  }

  #mapStyle {
    background-color: #222;
    color: white;
    padding: 10px;
    border: 1px solid #555;
    border-radius: 5px;
    font-size: 14px;
  }


  @keyframes blink {
    50% { color: transparent; }
  }

  #mac-label {
    position: absolute;
    top: 12px;
    right: 20px;
    margin-top: 10px;
    margin-left: 30px;
    background-color: rgba(31, 31, 31, 0.9);
    color: #80ffd3;
    padding: 6px 12px;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    border: 1px solid #80ffd3;
    border-radius: 4px;
    z-index: 999;
    display: none;
  }

#controls {
  position: absolute;
  margin-top: 60px;
  margin-left: 30px;
  z-index: 999;
  background-color: rgba(255, 255, 255, 0.92); /* Semi-transparent white */
  padding: 12px 16px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
  display: flex;
  flex-direction: column;  /* Stack children vertically */
  gap: 10px;               /* Space between stacked elements */
  align-items: stretch;    /* Make inputs and button full width */
  font-family: Arial, sans-serif;
}

#controls input[type="text"],
#controls input[type="date"],
#controls button {
  width: 100%;
  padding: 8px 12px;
  border-radius: 5px;
  font-size: 14px;
  box-sizing: border-box;
}


#controls input[type="text"],
#controls input[type="date"] {
  padding: 6px 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

#controls button {
  background-color: #4CAF50;
  color: white;
  padding: 8px 12px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s ease;
}

#controls button:hover {
  background-color: #388e3c;
}

</style>

<h2>Live GPS Route</h2>


<div class="top-panel">
  <button onclick="saveRoute()">üíæ Save Route</button>
  <select id="savedRoutes" onchange="loadRoute()">
    <option value="">üìÅ Load Saved Route</option>
  </select>
  <button onclick="deleteRoute()">üóëÔ∏è Delete Route</button>
  <select id="playSelect">
    <option value="live">‚ñ∂Ô∏è Play Live Route</option>
    <option value="saved">‚ñ∂Ô∏è Play Saved Route</option>
  </select>
  <button onclick="playRoute()">‚ñ∂Ô∏è Play</button>
  <button onclick="clearRoute()">üßπ Clear Map</button>
  <button id="toggleAuto" onclick="toggleAutoUpdate()">Auto-Update: ON</button>
  <button id="manualRefresh" onclick="fetchLiveRoute()" style="display:none;">üîÑ Refresh Now</button>
  <button id="loggingToggle" onclick="toggleLogging()">Enable Logging: ON</button>
  <button onclick="toggleAnalysis()">üìä Toggle Analysis</button>
<select id="mapStyle" onchange="changeMapStyle(this.value)">
  <option value="osm">üó∫Ô∏è OSM</option>
  <option value="satellite">üõ∞Ô∏è Satellite</option>
  <option value="dark">üåô Dark</option>
  <option value="toner">üñ§ Toner</option>
  <option value="opensea">‚öì OpenSeaMap</option>
</select>


</div>

<div id="map">  <!-- GPS Panel -->

  <div id="gps-panel">
    <div><strong>Latitude:</strong> <span id="lat-display">--</span></div>
    <div><strong>Longitude:</strong> <span id="lng-display">--</span></div>
    <div><strong>Speed:</strong> <span id="speed-display">--</span> km/h</div>
    <div><strong>GPS Probe:</strong> <span id="gps-probe" class="gps-off">‚óè</span></div>
  </div>

  <div id="controls" style="position: absolute; top: 100px; left: 20px; z-index: 999;">
    <input type="text" id="macInput" placeholder="Enter MAC address" />
    <input type="date" id="dateInput" />
    <button onclick="loadHistoricalRoute()">üìç Load Historical Route</button>
  </div>

    <!-- MAC label -->

  <div id="analysis-widget">
    <h4>üßÆ Analysis</h4>
    <button onclick="showElevation()">Elevation Profile</button>
    <button onclick="showSpeedGraph()">Speed Graph</button>
    <button onclick="toggleHeatmap()">Toggle Heatmap</button>
    <button onclick="detectIdleStops()">Detect Idle</button>
    <button onclick="colorBySpeed()">Color by Speed</button>
  </div>

  <div id="mac-label">MAC: <span id="mac-value">N/A</span></div>


  <div style="position:absolute; top:100px; right:20px; z-index:1000; background:white; padding:8px; border-radius:6px; color:black;">
    <strong>Speed Legend (km/h)</strong><br>
    <span style="color:blue;">‚óè</span> 0‚Äì10<br>
    <span style="color:limegreen;">‚óè</span> 10‚Äì30<br>
    <span style="color:orange;">‚óè</span> 30‚Äì60<br>
    <span style="color:red;">‚óè</span> 60+
  </div>

</div>


<!-- Leaflet core JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Then the Leaflet.heat plugin -->
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>


<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

{% endblock %}

{% block script_extra %}
<script>
let map = L.map('map').setView([37.5, 22.37], 16);
let routeLine = null;
let liveCoords = [];
let animMarker = null;
let startMarker = null;
let endMarker = null;

let autoUpdate = true;
let intervalId = null;
let heatLayer = null;

let speedLayerGroup = L.layerGroup().addTo(map);

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
});


const satellite = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
  {
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, Earthstar Geographics'
  }
);

const dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; CartoDB',
  subdomains: 'abcd'
});

const toner = L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', {
  attribution: 'Map tiles by Stamen Design'
});

const openSeaMap = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
  attribution: 'Map data ¬© OpenSeaMap contributors',
  transparent: true
});

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const tileLayers = {
  osm: osm,
  satellite: satellite,
  dark: dark,
  toner: toner,
  opensea: L.layerGroup([osm, openSeaMap])  // ‚¨ÖÔ∏è Add OpenSeaMap as a layer group
};


function changeMapStyle(style) {
  Object.values(tileLayers).forEach(layer => {
    if (map.hasLayer(layer)) map.removeLayer(layer);
  });

  const selectedLayer = tileLayers[style];

  if (selectedLayer instanceof L.LayerGroup) {
    selectedLayer.addTo(map);  // Group (like OSM + OpenSeaMap)
  } else {
    selectedLayer.addTo(map);  // Single layer
  }
}



let macAddress = '08:3A:8D:DE:E5:10';  // Default MAC address for testing, replace with actual MAC when available

let previousCoords = null;
let previousTimestamp = null;

function haversineDistance(lat1, lon1, lat2, lon2) {
  const toRad = deg => deg * Math.PI / 180;
  const R = 6371000; // Earth radius in meters
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function colorBySpeed() {
  if (liveCoords.length < 2) return alert("Not enough data");

  const segments = [];

  for (let i = 1; i < liveCoords.length; i++) {
    const prev = liveCoords[i - 1];
    const curr = liveCoords[i];

    const distance = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng); // in meters
    const timeDelta = (curr.timestamp - prev.timestamp) / 1000; // in seconds

    const speed = (distance / timeDelta) * 3.6; // in km/h
    let color = 'gray';

    if (speed < 5) color = 'blue';
    else if (speed < 15) color = 'green';
    else if (speed < 30) color = 'orange';
    else color = 'red';

    segments.push({
      coords: [[prev.lat, prev.lng], [curr.lat, curr.lng]],
      color
    });
  }

  // Clear existing route
  if (routeLine) {
    map.removeLayer(routeLine);
    routeLine = null;
  }
  if (startMarker) map.removeLayer(startMarker);
  if (endMarker) map.removeLayer(endMarker);

  // Draw colored segments
  for (const segment of segments) {
    L.polyline(segment.coords, { color: segment.color }).addTo(map);
  }

  // Optionally re-add start and end markers
  const start = liveCoords[0];
  const end = liveCoords[liveCoords.length - 1];
  startMarker = L.marker([start.lat, start.lng]).addTo(map).bindPopup("üö© Start");
  endMarker = L.marker([end.lat, end.lng]).addTo(map).bindPopup("üèÅ End");
}

function getSpeedColor(speed) {
  if (speed < 10) return 'blue';
  if (speed < 30) return 'limegreen';
  if (speed < 60) return 'orange';
  return 'red';
}

let heatVisible = false;

function toggleHeatmap() {
  if (!liveCoords.length) {
    alert("No GPS data to show heatmap.");
    return;
  }

  if (!heatVisible) {
    const heatData = liveCoords.map(p => [p.lat || p[0], p.lng || p[1], 1]);  // [lat, lng, intensity]
    heatLayer = L.heatLayer(heatData, { radius: 25, blur: 15, maxZoom: 17 });
    heatLayer.addTo(map);
    heatVisible = true;
    console.log("Heatmap enabled");
  } else {
    if (heatLayer) {
      map.removeLayer(heatLayer);
      heatLayer = null;
    }
    heatVisible = false;
    console.log("Heatmap disabled");
  }
}


function fetchLiveRoute(mac) {
  if (!mac || mac.trim() === '') {
    console.log("Error: MAC address is missing!");
    return;
  }

  console.log("Function: fetchLiveRoute() called");

  // Update MAC label on the UI
  const macLabelEl = document.getElementById("mac-value");
  if (macLabelEl) {
    macLabelEl.textContent = mac;
    document.getElementById("mac-label").style.display = "block";  // Make the label visible
  }

  fetch(`/gps/live?mac=${encodeURIComponent(mac)}`)
    .then(response => response.json())
    .then(data => {
      const lat = data.latitude;
      const lng = data.longitude;
      const now = Date.now();

      console.log(`Live GPS position from server: lat=${lat}, lng=${lng}`);

      // Update live UI panel
      document.getElementById("lat-display").textContent = lat.toFixed(6);
      document.getElementById("lng-display").textContent = lng.toFixed(6);

      // Blink GPS probe
      const probeEl = document.getElementById("gps-probe");
      if (probeEl) {
        probeEl.classList.remove("gps-on");
        void probeEl.offsetWidth; // reflow
        probeEl.classList.add("gps-on");
      }

      // Skip duplicate coordinates
      if (previousCoords && previousCoords.lat === lat && previousCoords.lng === lng) {
        console.log("Received same coordinates. Skipping.");
        return;
      }

      // Calculate speed
      const speedEl = document.getElementById("speed-display");
      if (previousCoords && previousTimestamp) {
        const distance = haversineDistance(previousCoords.lat, previousCoords.lng, lat, lng); // meters
        const timeDelta = (now - previousTimestamp) / 1000; // seconds
        const speedKph = (distance / timeDelta) * 3.6;
        if (speedEl) speedEl.textContent = speedKph.toFixed(2);
        console.log(`Speed: ${speedKph.toFixed(2)} km/h`);
      }

      // Save new previous values
      previousCoords = { lat, lng };
      previousTimestamp = now;

      // Only push once with full structure
      liveCoords.push({
        0: lat,  // needed for Leaflet
        1: lng,
        lat: lat,
        lng: lng,
        timestamp: now
      });

      drawRoute(liveCoords.map(c => [c.lat, c.lng]), 'blue');
    })
    .catch(err => {
      console.error("Error fetching GPS coordinates:", err);
      const probeEl = document.getElementById("gps-probe");
      if (probeEl) {
        probeEl.classList.remove("gps-on");
        probeEl.classList.add("gps-off");
      }
    });
}

function toggleAutoUpdate() {
  autoUpdate = !autoUpdate;
  const toggleBtn = document.getElementById('toggleAuto');
  const refreshBtn = document.getElementById('manualRefresh');

  if (autoUpdate) {
    toggleBtn.textContent = "Auto-Update: ON";
    refreshBtn.style.display = "none";
    if (macAddress) {  // Ensure valid MAC address is present before starting the interval
      intervalId = setInterval(() => fetchLiveRoute(macAddress), 2000);
    } else {
      console.log("Error: No MAC address available for auto-update");
    }
  } else {
    toggleBtn.textContent = "Auto-Update: OFF";
    refreshBtn.style.display = "inline-block";
    clearInterval(intervalId);
  }
}

// Call fetchLiveRoute only if MAC address is valid
if (macAddress) {
  fetchLiveRoute(macAddress);  // Initially fetch live route with valid MAC
} else {
  console.log("Error: No MAC address to fetch data");
}

intervalId = setInterval(() => {
  if (macAddress) {  // Check for a valid MAC address before making the request
    fetchLiveRoute(macAddress);
  }
}, 5000);

// Retry function in case of failure
function retryFetch(mac) {
  let retries = 3;
  let attempt = 0;

  const retryInterval = setInterval(() => {
    if (attempt >= retries) {
      console.log("Max retry attempts reached.");
      clearInterval(retryInterval);  // Stop retries after max attempts
      return;
    }
    attempt++;
    console.log(`Retrying fetch... Attempt ${attempt}`);
    fetchLiveRoute(mac);  // Attempt to fetch again
  }, 5000);  // Retry every 5 seconds
}

// Function to draw the route on the map
function drawRoute(coords, color) {
  console.log("Function: drawRoute() called with coords:", coords);  // Debugging entry point
  if (routeLine) map.removeLayer(routeLine);
  if (startMarker) map.removeLayer(startMarker);
  if (endMarker) map.removeLayer(endMarker);

  routeLine = L.polyline(coords, { color: color || 'blue' }).addTo(map);
  startMarker = L.marker(coords[0], { title: 'Start' }).addTo(map).bindPopup('üö© Start');
  endMarker = L.marker(coords[coords.length - 1], { title: 'End' }).addTo(map).bindPopup('üèÅ End');
  map.fitBounds(routeLine.getBounds());
}

// Toggle auto-update for the live route
function toggleAutoUpdate() {
  autoUpdate = !autoUpdate;
  const toggleBtn = document.getElementById('toggleAuto');
  const refreshBtn = document.getElementById('manualRefresh');

  console.log("Function: toggleAutoUpdate() called");  // Debugging entry point

  if (autoUpdate) {
    toggleBtn.textContent = "Auto-Update: ON";
    refreshBtn.style.display = "none";
    intervalId = setInterval(fetchLiveRoute, 5000);
  } else {
    toggleBtn.textContent = "Auto-Update: OFF";
    refreshBtn.style.display = "inline-block";
    clearInterval(intervalId);
  }
}

// Save current route
function saveRoute() {
  console.log("Function: saveRoute() called");  // Debugging entry point
  if (!liveCoords.length) return alert("Nothing to save.");
  const name = prompt("Enter name to save this route:");
  if (!name.match(/^[a-zA-Z0-9_-]+$/)) return alert("Invalid name!");
  fetch('/routes/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: name, coords: liveCoords.map(c => ({ lat: c[0], lng: c[1] })) })
  }).then(() => {
    alert("Route saved!");
    fetchSavedRoutes();
  });
}

// Load saved route
function loadRoute() {
  console.log("Function: loadRoute() called");  // Debugging entry point
  const name = document.getElementById('savedRoutes').value;
  if (!name) return;
  fetch(`/routes/load/${name}`)
    .then(res => res.json())
    .then(data => {
      const loaded = data.map(p => [p.lat, p.lng]);
      drawRoute(loaded, 'green');
    });
}

// Delete saved route
function deleteRoute() {
  console.log("Function: deleteRoute() called");  // Debugging entry point
  const name = document.getElementById('savedRoutes').value;
  if (!name) return;
  if (!confirm(`Delete route "${name}"?`)) return;
  fetch(`/routes/delete/${name}`, { method: 'DELETE' })
    .then(() => {
      alert("Route deleted!");
      fetchSavedRoutes();
    });
}

// Play route (live or saved)
function playRoute() {
  console.log("Function: playRoute() called");  // Debugging entry point
  const source = document.getElementById('playSelect').value;

  if (animMarker) map.removeLayer(animMarker);

  if (source === 'live') {
    if (!liveCoords.length) {
      alert("No live route data available.");
      return;
    }
    animateRoute(liveCoords);
  } else {
    const name = document.getElementById('savedRoutes').value;
    if (!name) return alert("Select a saved route to play.");
    fetch(`/routes/load/${name}`)
      .then(res => res.json())
      .then(data => {
        const coords = data.map(p => [p.lat, p.lng]);
        animateRoute(coords);
      });
  }
}

// Animate route on the map
function animateRoute(coords) {
  console.log("Function: animateRoute() called");  // Debugging entry point
  if (!coords.length) return;
  let i = 0;
  animMarker = L.marker(coords[0]).addTo(map);
  const interval = setInterval(() => {
    if (i >= coords.length) return clearInterval(interval);
    animMarker.setLatLng(coords[i++]);
  }, 300);
}

// Clear all routes and markers from the map
function clearRoute() {
  console.log("Function: clearRoute() called");  // Debugging entry point
  if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
  if (animMarker) { map.removeLayer(animMarker); animMarker = null; }
  if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
  if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
}

function toggleAnalysis() {
  const widget = document.getElementById('analysis-widget');
  if (widget.style.display === 'none') {
    widget.style.display = 'block';
  } else {
    widget.style.display = 'none';
  }
}

// Fetch saved routes from the server
function fetchSavedRoutes() {
  console.log("Function: fetchSavedRoutes() called");  // Debugging entry point
  fetch('/routes')
    .then(res => res.json())
    .then(routes => {
      const dropdown = document.getElementById('savedRoutes');
      dropdown.innerHTML = '<option value="">üìÅ Load Saved Route</option>';
      routes.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        dropdown.appendChild(opt);
      });
    });
}

// Function to send GPS data to the server via POST
function sendGpsData(lat, lng, mac) {
  console.log(`Function: sendGpsData() called with lat: ${lat}, lng: ${lng}, mac: ${mac}`);  // Debugging entry point

  // Get the value of the logging toggle checkbox
  const loggingEnabled = document.getElementById("loggingToggle").checked;  // true if checked, false if unchecked

  // Prepare the JSON payload
  const jsonPayload = {
    latitude: lat,
    longitude: lng,
    mac: mac,
    logging_enabled: loggingEnabled  // Include the logging flag in the request payload
  };

  // Log the payload before sending
  console.log(`Sending data: ${JSON.stringify(jsonPayload)}`);

  // Use fetch to send the data as JSON
  fetch('/gps', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'  // Set content type to JSON
    },
    body: JSON.stringify(jsonPayload)  // Convert the object to JSON
  })
  .then(response => response.json())  // Expect a JSON response from the server
  .then(data => {
    console.log("Data sent successfully:", data);  // Log the server response
  })
  .catch(error => {
    console.error("Error sending GPS data:", error);  // Log any errors
  });
}

function detectIdleStops() {
  console.log("Function: detectIdleStops() called");

  if (liveCoords.length < 2) {
    alert("Not enough data to detect idle stops.");
    return;
  }

  const idleStops = [];

  for (let i = 1; i < liveCoords.length; i++) {
    const prev = liveCoords[i - 1];
    const curr = liveCoords[i];

    const distance = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
    const timeDelta = (curr.timestamp - prev.timestamp) / 1000;
    const speed = (distance / timeDelta) * 3.6;

    if (speed < 2.0) {  // Consider < 2 km/h as idle
      idleStops.push(curr);
    }
  }

  if (idleStops.length === 0) {
    alert("No idle stops detected.");
    return;
  }

  // Show markers for idle stops
  idleStops.forEach(point => {
    L.circleMarker([point.lat, point.lng], {
      color: 'red',
      radius: 6
    }).addTo(map).bindPopup("üõë Idle stop");
  });

  alert(`Detected ${idleStops.length} idle stops.`);
}

// Show speed graph
function showSpeedGraph() {
  console.log("Function: showSpeedGraph() called");
  if (liveCoords.length < 2) return alert("Not enough data");

  const speeds = [];
  const labels = [];

  for (let i = 1; i < liveCoords.length; i++) {
    const prev = liveCoords[i - 1];
    const curr = liveCoords[i];

    const distance = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng); // meters
    const timeDelta = (curr.timestamp - prev.timestamp) / 1000; // seconds

    const speed = (distance / timeDelta) * 3.6; // km/h
    speeds.push(speed.toFixed(2));
    labels.push(i); // just use point index as label
  }

  const ctx = document.createElement('canvas');
  ctx.style.width = "600px";
  ctx.style.height = "300px";
  ctx.style.display = "block";
  ctx.style.margin = "30px auto";
  document.body.appendChild(ctx);

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'Speed (km/h)',
        data: speeds,
        borderColor: 'orange',
        fill: false,
        tension: 0.3
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true }
      },
      scales: {
        y: { beginAtZero: true }
      }
    }
  });
}

function loadHistoricalRoute() {
  const mac = document.getElementById('macInput').value.trim();
  const date = document.getElementById('dateInput').value;

  if (!mac) {
    alert("Please enter a MAC address.");
    return;
  }

  const url = `/api/coords?mac=${encodeURIComponent(mac)}${date ? `&date=${date}` : ''}`;
  console.log("Loading route from:", url);

  fetch(url)
    .then(res => res.json())
    .then(data => {
      if (!Array.isArray(data) || data.length === 0) {
        alert("No data found for this MAC/date.");
        return;
      }

      const latlngs = data.map(p => [p.lat, p.lng]);

      // Clear previous route
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);

      // Draw new route
      routeLine = L.polyline(latlngs, { color: 'red' }).addTo(map);
      startMarker = L.marker(latlngs[0]).addTo(map).bindPopup("üö© Start");
      endMarker = L.marker(latlngs[latlngs.length - 1]).addTo(map).bindPopup("üèÅ End");
      map.fitBounds(routeLine.getBounds());

      // Save inputs for next load
      localStorage.setItem("lastMac", mac);
      if (date) localStorage.setItem("lastDate", date);
    })
    .catch(err => {
      console.error("Error loading historical route:", err);
      alert("Failed to load route.");
    });
}

// Load last used MAC/date on page load
window.addEventListener("DOMContentLoaded", () => {
  const savedMac = localStorage.getItem("lastMac");
  const savedDate = localStorage.getItem("lastDate");
  if (savedMac) document.getElementById("macInput").value = savedMac;
  if (savedDate) document.getElementById("dateInput").value = savedDate;
});


fetchSavedRoutes();
</script>
{% endblock %}
